<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="里面有我的个人感悟和牢骚">
<meta property="og:type" content="website">
<meta property="og:title" content="Whosemario的家">
<meta property="og:url" content="http://whosemario.github.io/index.html">
<meta property="og:site_name" content="Whosemario的家">
<meta property="og:description" content="里面有我的个人感悟和牢骚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Whosemario的家">
<meta name="twitter:description" content="里面有我的个人感悟和牢骚">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'always',
    motion: true
  };
</script>

  <title> Whosemario的家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Whosemario的家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="http://www.ixirong.com/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/cpp-right-ref/" itemprop="url">
                  C++11的右值引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-09-05T09:32:46+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/05/cpp-right-ref/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/05/cpp-right-ref/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>好久没有写文章了，一是因为最近公司项目比较紧，二是在看c++，工作两年多c++的知识都忘记了，今天就来简单总结一下c++11的右值引用。<br>提前声明，本文参考了<a href="http://www.cnblogs.com/qicosmos/p/4283455.html" target="_blank" rel="external">从4行代码看右值引用</a></p>
</blockquote>
<h4 id="1-右值引用要解决的问题">1.右值引用要解决的问题</h4><p>c++11引入右值引用要解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。<br>在c++11中所有的值分为三种类型：左值、将亡值、纯右值。纯右值是非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等；将亡值是将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。</p>
<h4 id="2-几个尝试性的测试">2.几个尝试性的测试</h4><p>测试基本代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> g_contr_cnt = <span class="number">0</span>;
<span class="keyword">int</span> g_decontr_cnt = <span class="number">0</span>;
<span class="keyword">int</span> g_copy_cnt = <span class="number">0</span>;

<span class="keyword">class</span> A {
<span class="keyword">public</span>:
    A() {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct: "</span> &lt;&lt; ++g_contr_cnt &lt;&lt; endl;
    }

    A(<span class="keyword">const</span> A&amp; oth) {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy: "</span> &lt;&lt; ++g_copy_cnt &lt;&lt; endl;
    }

    ~A() {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct: "</span> &lt;&lt; ++g_decontr_cnt &lt;&lt; endl;
    }
};

<span class="function">A <span class="title">getVal</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> A();
}
</code></pre><h5 id="测试1：值拷贝">测试1：值拷贝</h5><pre><code><span class="keyword">A</span> x = getVal()<span class="comment">;</span>
</code></pre><p>由于编辑器会对代码进行优化，因此我们在编译上面的代码的时候，加入-fno-elide-constructors，运行结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">3</span>
</code></pre><p>调用了两次复制构造函数，一次在返回值，一次在对x的赋值。如果A类的复制构造函数不是简简单单地打印信息，而是有大量内存的拷贝，那怎么办？两次复制构造函数性能开销就会很大，并且关键的是拷贝源实例是一个将亡值，留下它根本没有什么用。</p>
<p><strong>换一种方案：const A&amp;</strong></p>
<pre><code>const <span class="keyword">A</span>&amp; x = getVal()<span class="comment">;</span>
</code></pre><p>这时候输出结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
</code></pre><p>但const reference是不能修改引用的内容的！</p>
<p><strong>另一个方案：右值引用</strong></p>
<pre><code><span class="keyword">A</span>&amp;&amp; x = getVal()<span class="comment">;</span>
</code></pre><p>这样输出结果与上面一种方案是一样的，并且x并不是一个const类型。右值引用将返回的值“续命”了。</p>
<h5 id="测试2：移动构造函数">测试2：移动构造函数</h5><p>我们现在类的定义中加入移动构造函数：</p>
<pre><code><span class="literal">A</span>(<span class="literal">A</span>&amp;&amp; oth) {
    cout &lt;&lt; <span class="string">"move: "</span> &lt;&lt; ++g_move_cnt &lt;&lt; endl<span class="comment">;</span>
}
</code></pre><p>这样子，我们再看一下输出结果：</p>
<pre><code><span class="keyword">A</span> x = getVal()<span class="comment">;</span>
</code></pre><p>输出结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">3</span>
</code></pre><p>没有拷贝构造函数了，与之代替的是移动构造函数，移动构造函数的实现，我们可以认为移动源实例是一个将亡值，这样我们在移动构造函数的内部实现中只需要将移动源实例move到新的实例中即可。</p>
<h4 id="测试3：参数A&amp;&amp;">测试3：参数A&amp;&amp;</h4><pre><code><span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(A&amp;&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;
</code></pre><p>这两个函数，编译器是怎样判断的呢？做了一些尝试：</p>
<pre><code>A x<span class="comment">;</span>
setVal<span class="list">(<span class="keyword">x</span>)</span><span class="comment">;   // 左值</span>
setVal<span class="list">(<span class="keyword">std</span>:<span class="keyword">:move</span><span class="list">(<span class="keyword">x</span>)</span>)</span><span class="comment">;   // 右值</span>
setVal<span class="list">(<span class="keyword">A</span><span class="list">()</span>)</span><span class="comment">;   // 右值</span>
A&amp;&amp; y = getVal<span class="list">()</span><span class="comment">;</span>
setVal<span class="list">(<span class="keyword">y</span>)</span><span class="comment">;  // 左值</span>
</code></pre><h4 id="测试4：std::move">测试4：std::move</h4><p>std::move是c++11提供移动实例的方式，测试代码如下：</p>
<pre><code><span class="keyword">A</span> x<span class="comment">;</span>
<span class="keyword">A</span> y = st<span class="number">d::</span>move(x)<span class="comment">;</span>
</code></pre><p>y的初始化使用了移动构造函数：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
</code></pre><p>如果类A没有移动构造函数，将会使用复制构造函数。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/20/lscpu-cmd/" itemprop="url">
                  lscpu中的 socket、core、thread的意义
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-05-20T14:17:33+08:00" content="2016-05-20">
              2016-05-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/20/lscpu-cmd/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/20/lscpu-cmd/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Linux上如下指令可以查看CPU的信息</p>
<pre><code><span class="blockquote">&gt; lscpu</span>
</code></pre><p>在我们线上机器上的结果如下：</p>
<pre><code>Architecture:          x86_64
CPU <span class="function"><span class="title">op-mode</span><span class="params">(s)</span></span>:        <span class="number">32</span>-bit, <span class="number">64</span>-bit
Byte Order:            Little Endian
<span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:                <span class="number">32</span>
On-line <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span> list:   <span class="number">0</span>-<span class="number">31</span>
<span class="function"><span class="title">Thread</span><span class="params">(s)</span></span> per core:    <span class="number">2</span>
<span class="function"><span class="title">Core</span><span class="params">(s)</span></span> per socket:    <span class="number">8</span>
<span class="function"><span class="title">Socket</span><span class="params">(s)</span></span>:             <span class="number">2</span>
NUMA <span class="function"><span class="title">node</span><span class="params">(s)</span></span>:          <span class="number">2</span>
Vendor ID:             GenuineIntel
CPU family:            <span class="number">6</span>
Model:                 <span class="number">62</span>
Model name:            <span class="function"><span class="title">Intel</span><span class="params">(R)</span></span> <span class="function"><span class="title">Xeon</span><span class="params">(R)</span></span> CPU E5-<span class="number">2640</span> v2 @ <span class="number">2.00</span>GHz
Stepping:              <span class="number">4</span>
CPU MHz:               <span class="number">1320.468</span>
CPU max MHz:           <span class="number">2500.0000</span>
CPU min MHz:           <span class="number">1200.0000</span>
BogoMIPS:              <span class="number">4000.99</span>
Virtualization:        VT-x
L1d cache:             <span class="number">32</span>K
L1i cache:             <span class="number">32</span>K
L2 cache:              <span class="number">256</span>K
L3 cache:              <span class="number">20480</span>K
NUMA node0 <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:     <span class="number">0</span>-<span class="number">7</span>,<span class="number">16</span>-<span class="number">23</span>
NUMA node1 <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:     <span class="number">8</span>-<span class="number">15</span>,<span class="number">24</span>-<span class="number">31</span>
</code></pre><p>上面的信息，有几个比较有意思：</p>
<pre><code><span class="function"><span class="title">Thread</span><span class="params">(s)</span></span> per core:    <span class="number">2</span>
<span class="function"><span class="title">Core</span><span class="params">(s)</span></span> per socket:    <span class="number">8</span>
<span class="function"><span class="title">Socket</span><span class="params">(s)</span></span>:             <span class="number">2</span>
</code></pre><h5 id="什么是Socket">什么是Socket</h5><p>Socket就是主板上插CPU的槽的数量</p>
<h5 id="什么是Core">什么是Core</h5><p>Core就是平时说的核，双核、四核等，就是每个CPU上的核数</p>
<h5 id="什么是Thread">什么是Thread</h5><p>thread就是每个core上的硬件线程数，即超线程</p>
<p>对操作系统来说，其逻辑CPU的数量就是Socket*Core*Thread</p>
<h3 id="参考资料">参考资料</h3><p>[1] <a href="http://diego.assencio.com/?index=614d73283d49e939ebfb648cfb86819d" target="_blank" rel="external">Getting CPU architecture information with lscpu</a><br>[2] <a href="http://blog.chinaunix.net/uid-20940095-id-3596134.html" target="_blank" rel="external"> 处理器三个概念理解及延伸（socket，core，thread，SMT，CMP，SMP）</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/virtual-memory/" itemprop="url">
                  虚拟内存管理（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-05-18T16:18:51+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/virtual-memory/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/virtual-memory/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>很久以前就想写一下关于虚拟内存管理方面的文章，主要还是写给自己看的。原因主要是自己对Linux虚拟内存管理也是一知半解，写一篇博客，记录一下自己这几天的学习笔记，留着以后做参考。</p>
</blockquote>
<p>这一篇主要讲一下虚拟地址到物理地址的转换。主要参考《深入理解计算机系统》一书。</p>
<h3 id="关于逻辑地址、线性地址和物理地址">关于逻辑地址、线性地址和物理地址</h3><h5 id="物理地址：">物理地址：</h5><p>物理地址可以想象成实际物理存储上的地址 </p>
<h5 id="线性地址：">线性地址：</h5><p>线性地址也可以叫做虚拟地址，是一个不真实的地址，可以理解为页式管理中的地址      </p>
<h5 id="逻辑地址：">逻辑地址：</h5><p>逻辑地址与线性地址一样，是一个不真实的地址，用于Intel段式管理中的地址      </p>
<h5 id="三个地址的转换关系：">三个地址的转换关系：</h5><p>逻辑地址–&gt;线性地址–&gt;物理地址</p>
<h3 id="逻辑地址–&gt;线性地址">逻辑地址–&gt;线性地址</h3><p>逻辑地址由两部分组成，段标识符和段内偏移地址。段标识符是有个16位长的字段组成，叫做段选择符。其中高13位是一个索引号，如下图：<br><img src="/images/virtual-memory-1-1.png" alt=""></p>
<p>索引号用于索引段描述符表的某一段描述符，段描述符格式如下图：<br><img src="/images/virtual-memory-1-2.png" alt=""></p>
<p>在Linux下，段描述符的Base都是0，因此逻辑地址的段内偏移量就是线性地址，接下来看一下线性地址怎样转换成物理地址的。</p>
<h3 id="线性地址–&gt;物理地址">线性地址–&gt;物理地址</h3><p>首先宏观上的看一下线性地址（虚拟地址）到物理地址的转换<br><img src="/images/virtual-memory-1-3.png" alt=""></p>
<p>虚拟地址高位有一个页表索引，通过页表索引可以在页表中找到对应的一个页表入口(Page Table Entry)，在PTE中可以得到物理页号，然后在加上原先在虚拟地址中的偏移量，就会定位到最终的地址。</p>
<h4 id="基本流程">基本流程</h4><p><img src="/images/virtual-memory-1-4.png" alt=""></p>
<p>如上图是一个正常的命中流程：    </p>
<ol>
<li>处理器生成一个虚拟地址，并将其给MMU</li>
<li>MMU生成一个PTE地址，从高速缓存/主存中请求获取</li>
<li>高速缓存/主存将PTE数据传回MMU</li>
<li>MMU生成物理地址，传给高速缓存/主存</li>
<li>高速缓存/主存将数据传回处理器</li>
</ol>
<p><img src="/images/virtual-memory-1-5.png" alt=""></p>
<p>上图是发生缺页中断的情况，高速缓存/主存会将牺牲页换出，将新页换进。</p>
<h4 id="利用TLB加速地址翻译">利用TLB加速地址翻译</h4><p>TLB全称翻译后备缓冲器(Translation Lookaside Buffer)，位于MMU内存，其实就是缓存住了一些PTE，那么MMU就不需要从高速缓存/主存中获取PTE了。</p>
<h4 id="多级页表">多级页表</h4><p>如果是32位的虚拟地址空间，一个页的大小为4K，那一张页表就有1M个PTE，如果每个PTE的大小为4个字节，那么页表占用内存大小为4MB。如果是64位机器，它的寻址位数是48位，那页表就更大了。<br>解决方式是讲页表分为多级，如下图：<br><img src="/images/virtual-memory-1-6.png" alt="">  </p>
<p>地址翻译的过程基本就差不多了。 </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/21/Mangos-Zero-1/" itemprop="url">
                  Mangos Zero 编译安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-21T19:49:41+08:00" content="2016-04-21">
              2016-04-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/21/Mangos-Zero-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/21/Mangos-Zero-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>本篇文章是我几个月前在CSDN的blog上写的，现在移过来</p>
<p>折腾了两天，终于将Mangos Zero在自己的Windows电脑上搭建起来了，下面总结一下安装Mangos Zero过程。网上也有很多安装Mangos Zero的教程，都比较老了，有些基本不能用了。</p>
</blockquote>
<h3 id="1-_安装环境">1. 安装环境</h3><ol>
<li>Windows XP 64位</li>
</ol>
<h3 id="2-_前期准备">2. 前期准备</h3><ol>
<li><a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">MySQL</a>（本人使用的是5.5的版本）</li>
<li><a href="http://code.google.com/p/sqlyog/wiki/Downloads" target="_blank" rel="external">SQLyog</a>（这个根据个人喜好，就是MySQL的GUI）</li>
<li><a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git</a></li>
<li>World of Warcraft 1.12 (Google找一下，我这边有一个，但忘记网址了，过一阵子上传到网盘上)</li>
<li>VS 2010 或更高版本 （本人是VS2013）</li>
</ol>
<h3 id="3-_安装MySQL">3. 安装MySQL</h3><p>MySQL的安装我就不多说了，不会的网上一大堆教程的，这里要记住MySQL安装过程中设置的密码，后面会用到。</p>
<h3 id="4-_安装Git">4. 安装Git</h3><p>安装指引一步一步安装就好，没有什么可注意的地方。</p>
<h3 id="5-_创建一个根目录">5. 创建一个根目录</h3><p>创建一个名为Mangos的根目录，下面的所有操作我们都会在这个目录下进行</p>
<h3 id="6-_下载database">6. 下载database</h3><pre><code>&gt; cd Mangos
&gt; git <span class="keyword">clone</span> <span class="title">--recursive</span> http://github.com/mangoszero/database.git -b develop21
</code></pre><p>这里要多少几句，我使用的是<strong>develop21</strong>分支，一开始我使用的是<strong>release20</strong>这个分支，但发现database和server的版本不匹配，并且按网上的说法打Patch都解决不了，所有就用了最新的开发分支，经本人测试完全可用。因为是开发分支，可能开发者在上面修改导致一些其他问题，所以我自己也fork了一个这样的分支，大家也可用clone我自己的git</p>
<pre><code>git <span class="keyword">clone</span> <span class="title">--recursive</span> https://github.com/Whosemario/database.git -b develop21
</code></pre><h3 id="7-将数据加载到MySQL">7.将数据加载到MySQL</h3><pre><code><span class="blockquote">&gt; cd Mangos</span>
<span class="blockquote">&gt; cd database</span>
<span class="blockquote">&gt; InstallDatabases.bat</span>
</code></pre><p>起始就是运行database文件夹下的<strong>InstallDatabases.bat</strong>脚本。跟着提示一路配置下去。几点要注意：</p>
<ol>
<li>第一步输入N进行下一步</li>
<li>MySQL的密码就是上面安装MySQL设置的密码</li>
<li>没有其他什么要求，剩下的配置都使用默认就好，下面的教程将根据默认配置来<br>如果一切顺利，你会在MySQL里面看到三个新的数据库，如下<br><img src="http://img.blog.csdn.net/20151205222912569" alt="这里写图片描述"><br>它们分别是<strong>character0</strong> <strong>mangos0</strong> <strong>realmd</strong><br>此时还没完，这里的character0的版本会和mangos server的版本不一致，打开character0的db_version这张表。<br><img src="http://img.blog.csdn.net/20151205223222361" alt="这里写图片描述"><br>它的structure一列位1，但server需要的版本为2，所以我们要为character0打个Patch，在database/Character/Updates/rel21/目录下有一个sql文件Rel21_2_0_honor_flush.sql，将其运行即可。</li>
</ol>
<h3 id="8-_下载server">8. 下载server</h3><pre><code>&gt; cd Mangos
&gt; git <span class="keyword">clone</span> <span class="title">https</span>://github.com/mangoszero/server.git --recursive -b develop21
</code></pre><p>相同的，我也有一个对应的repo</p>
<pre><code>git <span class="keyword">clone</span> <span class="title">https</span>://github.com/Whosemario/server.git -b develop21
</code></pre><h3 id="9-_编译server">9. 编译server</h3><p>到Mangos/server/win目录下，里面有很多安装软件，分别安装cmake和openssl，然后运行MaNGOS_EasyBuild.exe，点击按钮<strong>Check</strong> <strong>Now</strong>，如果上面的安装一切正常，会如图<br><img src="http://img.blog.csdn.net/20151205224009966" alt="这里写图片描述"><br>点击Build Options，会有一些基本选项，按自己的需求去选择，没有什么大问题，然后点击Generate Project，最后会打开你的Visual Studio，然后rebuild整个项目，项目rebuild成功后，会在Mangos文件加下生成<strong>server_build</strong>的目录，然后进行下面两步操作：</p>
<ol>
<li>将server_build/bin/Debug/下的文件都拷贝到你的WoW客户端的根目录（也就是WoW.exe所在的目录）</li>
<li>再将server_build/bin/Debug/tools/下的文件都拷贝到你的WoW客户端的根目录</li>
<li>在WoW客户端目录下，运行<strong>ExtractResources.sh</strong>，跟着指引一步一步配置，当运行完后，会生成三个目录 <strong>dbc</strong> <strong>maps</strong> <strong>vmaps</strong>。</li>
<li>在Mangos目录下新建名为Data的文件夹，将上面的三个目录拷贝到Data文件夹下</li>
</ol>
<h3 id="10-_配置Mangos_Server">10. 配置Mangos Server</h3><ol>
<li><p>进入Mangos/server_build/bin/Debug/文件夹下，将mangosd.conf.dist文件重命名为mangosd.conf，并修改里面的内容</p>
<pre><code><span class="setting">DataDir = <span class="value"><span class="string">"."</span>    </span></span>
</code></pre><p> 修改为</p>
<pre><code><span class="setting">DataDir = <span class="value"><span class="string">"C:\Mangos\Data"</span></span></span>
</code></pre><p> 假设你的Mangos新建在C盘根目录下。</p>
<pre><code>LoginDatabaseInfo      "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;realmd"</span>
WorldDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;mangos"</span>
ScriptDev2DatabaseInfo = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;mangos"</span>
CharacterDatabaseInfo  = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;character0"</span>
</code></pre></li>
</ol>
<p>修改为：</p>
<pre><code>LoginDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;realmd"</span>
WorldDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;mangos0"</span>
ScriptDev2DatabaseInfo = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;mangos0"</span>
CharacterDatabaseInfo  = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;characters"</span>
</code></pre><p>假设你的MySQL密码为123456.</p>
<ol>
<li><p>将realmd.conf.dist文件重命名为realmd.conf</p>
<pre><code>LoginDatabaseInfo     = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;realmd"</span>
</code></pre><p>改为：</p>
<pre><code>LoginDatabaseInfo     = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;realmd"</span>
</code></pre></li>
<li>修改realmd数据库里面的realmlist表，将第一列带有MaNGOS的字符串替换为MyWoW</li>
</ol>
<h3 id="11-_修改客户端">11. 修改客户端</h3><ol>
<li>打开realmlist.wtf，将最后的域名改为127.0.0.1</li>
</ol>
<h3 id="12-_启动游戏">12. 启动游戏</h3><ol>
<li>打开Mango\server_build\bin\Debug\realmd.exe<br> <img src="http://img.blog.csdn.net/20151205225953575" alt="这里写图片描述"></li>
<li>打开Mango\server_build\bin\Debug\mangosd.exe<br> <img src="http://img.blog.csdn.net/20151205230127299" alt="这里写图片描述"></li>
<li>新建一个玩家<br><img src="http://img.blog.csdn.net/20151205230359778" alt="这里写图片描述"></li>
<li><p>打开客户端WoW.exe<br><img src="http://img.blog.csdn.net/20151205232214037" alt="这里写图片描述"></p>
<h3 id="reference">reference</h3></li>
<li><p><a href="https://www.getmangos.eu/wiki/Installation%20Guides/Windows/MaNGOS%20Rel21.md" target="_blank" rel="external">How to Setup a MaNGOS Rel21 Server from Scratch</a></p>
</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/05/interview-book/" itemprop="url">
                  一本很有意义的GitBook
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-05T21:44:57+08:00" content="2016-04-05">
              2016-04-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/05/interview-book/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/05/interview-book/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>最近在维护一本<a href="https://www.gitbook.com/book/whosemario/interview-book/details" target="_blank" rel="external">Gitbook</a>，和面试相关的，本人将持续维护中…</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/26/docker-tutorial/" itemprop="url">
                  Mac OSX Docker 教程 (一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-26T19:09:32+08:00" content="2016-03-26">
              2016-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/26/docker-tutorial/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/26/docker-tutorial/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>本文基于Docker官方网站的<a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac OSX教程</a>所写。</p>
</blockquote>
<h3 id="安装Docker_Toolbox">安装Docker Toolbox</h3><p>Docker Toolbox包含如下的Docker工具：</p>
<ul>
<li>Docker CLI 用于创建Docker镜像和Docker容器</li>
<li>Docker Machine 让你可以在Mac OSX以命令行的方式操作Docker引擎</li>
<li>Docker Compose用于运行docker-compose命令</li>
<li>Kitematic —— Docker的GUI组件</li>
<li>Docker快速启动shell</li>
<li>Oracle VM 虚拟机</li>
</ul>
<h4 id="步骤一：检查系统版本号">步骤一：检查系统版本号</h4><p>检查操作系统版本号，版本号必须 &gt;= 10.8</p>
<h4 id="步骤二：安装Docker_Tool">步骤二：安装Docker Tool</h4><p>下载<a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="external">Docker Toolbox</a>并开始进行安装，安装很傻瓜，一路next就可以。</p>
<h4 id="步骤三：检查是否安装成功">步骤三：检查是否安装成功</h4><ol>
<li><p>首先开启Docker Quickstart Terminal</p>
<p> <img src="/images/docker-tutorial-1-p1.png" alt=""></p>
</li>
<li><p>终端会有如下输出</p>
<pre><code><span class="type">Last</span> login: <span class="type">Sat</span> <span class="type">Jul</span> <span class="number">11</span> <span class="number">20</span>:<span class="number">09</span>:<span class="number">45</span> on ttys002
bash '/<span class="type">Applications</span>/<span class="type">Docker</span> <span class="type">Quickstart</span> <span class="type">Terminal</span>.app/<span class="type">Contents</span>/<span class="type">Resources</span>/<span class="type">Scripts</span>/    start.sh'
<span class="type">Get</span> http:<span class="comment">///var/run/docker.sock/v1.19/images/json?all=1&amp;filters=%7B%22dangling%22%3A%5B%22true%22%5D%7D: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?</span>
<span class="type">Get</span> http:<span class="comment">///var/run/docker.sock/v1.19/images/json?all=1: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?</span>
-bash: lolcat: command not found

mary at meepers in ~
$ bash '/<span class="type">Applications</span>/<span class="type">Docker</span> <span class="type">Quickstart</span> <span class="type">Terminal</span>.app/<span class="type">Contents</span>/<span class="type">Resources</span>/<span class="type">Scripts</span>/start.sh'
<span class="type">Creating</span> <span class="type">Machine</span> dev...
<span class="type">Creating</span> <span class="type">VirtualBox</span> <span class="type">VM</span>...
<span class="type">Creating</span> <span class="type">SSH</span> key...
<span class="type">Starting</span> <span class="type">VirtualBox</span> <span class="type">VM</span>...
<span class="type">Starting</span> <span class="type">VM</span>...
<span class="type">To</span> see how to connect <span class="type">Docker</span> to <span class="keyword">this</span> machine, run: docker-machine env dev
<span class="type">Starting</span> machine dev...
<span class="type">Setting</span> environment variables <span class="keyword">for</span> machine dev...

                    ##         .
              ## ## ##        ==
           ## ## ## ## ##    ===
       /<span class="string">""""""</span><span class="string">""""""</span><span class="string">"""""\___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
       \______ o           __/
         \    \         __/
          \____\_______/

The Docker Quick Start Terminal is configured to use Docker with the “default” VM.</span>
</code></pre></li>
<li><p>键入<strong>docker run hello-world</strong></p>
<pre><code>$ docker run hello-world
Unable <span class="built_in">to</span> find image <span class="string">'hello-world:latest'</span> locally
latest: Pulling <span class="built_in">from</span> library/hello-world
<span class="number">535020</span>c3e8ad: Pull complete
af340544ed62: Pull complete
Digest: sha256:a68868bfe696c00866942e8f5ca39e3e31b79c1e50feaee4ce5e28df2f051d5c
Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest

Hello <span class="built_in">from</span> Docker.
This message shows that your installation appears <span class="built_in">to</span> be working correctly.

To generate this message, Docker took <span class="operator">the</span> following steps:
<span class="number">1.</span> The Docker Engine CLI client contacted <span class="operator">the</span> Docker Engine daemon.
<span class="number">2.</span> The Docker Engine daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub.
<span class="number">3.</span> The Docker Engine daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span> executable that produces <span class="operator">the</span> output you are currently reading.
<span class="number">4.</span> The Docker Engine daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker Engine CLI client, which sent <span class="keyword">it</span> <span class="built_in">to</span> your terminal.

To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>:
$ docker run -<span class="keyword">it</span> ubuntu bash

Share images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account:
<span class="keyword">https</span>://hub.docker.com

For more examples <span class="operator">and</span> ideas, visit:
<span class="keyword">https</span>://docs.docker.com/userguide/
</code></pre></li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/net-io-model/" itemprop="url">
                  网络IO模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-23T19:36:12+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络模型/" itemprop="url" rel="index">
                    <span itemprop="name">网络模型</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/23/net-io-model/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/23/net-io-model/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>这里对网络IO做一次总结</p>
</blockquote>
<p>《Unix网络编程》一书中对网络IO模型的总结如下：</p>
<ul>
<li>同步模型（synchronous I/O）<ul>
<li>阻塞I/O（bloking I/O）</li>
<li>非阻塞I/O（non-blocking I/O）</li>
<li>多路复用I/O（multiplexing I/O）</li>
<li>信号驱动式I/O（signal-driven I/O）</li>
</ul>
</li>
<li>异步I/O（asynchronous I/O）</li>
</ul>
<h3 id="阻塞I/O">阻塞I/O</h3><p>阻塞IO是最常用的模式，进程发起<strong>recvfrom</strong>系统调用后，进程就被阻塞了，然后等待数据准备好，数据从内核态拷贝到用户态后，进程再进行处理。     </p>
<p><img src="/images/net-io-1.jpg" alt=""></p>
<h3 id="非阻塞I/O">非阻塞I/O</h3><p>非阻塞IO正好相反，进程发起<strong>recvfrom</strong>系统调用后不会阻塞，马上会得到返回结果，如果此时没有数据，会返回EWOULDBLOCK，用户进程可以不断地尝试<strong>recefrom</strong>，然后有数据处理的时候，函数调用仍然是阻塞的。</p>
<p><img src="/images/net-io-2.jpg" alt=""></p>
<h3 id="多路复用I/O">多路复用I/O</h3><p>多路复用有两个系统调用<strong>select</strong>和<strong>poll</strong>，就<strong>select</strong>函数来说，其可以监听多个文件描述符，当有数据可以处理的时候，系统调用将会返回，然后用户进行可以调用<strong>recvfrom</strong>进行数据读取。</p>
<p><img src="/images/net-io-3.jpg" alt=""></p>
<h3 id="异步I/O">异步I/O</h3><p>用户进程进行<strong>aio_read</strong>系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。</p>
<p><img src="/images/net-io-4.jpg" alt=""></p>
<h3 id="同步和异步模型的区别">同步和异步模型的区别</h3><p><img src="/images/net-io-5.jpg" alt=""></p>
<p>关于同步和异步，我的理解是数据的获取方式：同步模型，数据是用户态尝试去向内核态获取数据的；异步模型，数据是从内核态拷贝到用户态，并通知用户进程数据ok了。</p>
<h3 id="关于epoll">关于epoll</h3><p><strong>epoll</strong>到底是同步还是异步的呢？<br>我们知道<strong>epoll</strong>属于多路复用IO，那么它应该是同步的。但是，<strong>epoll</strong>因为采用mmap的机制，使得内核socket buffer和用户空间的buffer共享，从而省去了数据拷贝，这也意味着，当<strong>epoll</strong>回调上层的 callback函数来处理socket数据时，数据已经从内核层“自动“”到了用户空间。<br>stevens老爷子写《Unix网络编程》已经是上个世纪的事情了，当时<strong>epoll</strong>还没有，我觉得<strong>epoll</strong>不属于任何一种吧。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/20/lock-structure/" itemprop="url">
                  线程间共享数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-20T09:32:47+08:00" content="2016-03-20">
              2016-03-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/20/lock-structure/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/20/lock-structure/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>本文是基于《C++并发编程》第三章的读书笔记</p>
</blockquote>
<h3 id="1-条件竞争(race_condition)">1.条件竞争(race condition)</h3><p>并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。大多数情况下，即使改变执行顺序，也是良性竞争，其结果可以接受。恶性条件竞争通常发生于完成对多于一个的数据块的修改时，例如，对两个连接指针的修改。因为操作要访问两个独立的数据块，独立的指令将会对数据块将进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。<br>保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量(mutex)。</p>
<h3 id="2-C++11的互斥器">2.C++11的互斥器</h3><p><a href="http://whosemario.github.io/2016/03/18/concurrency-program/">上一篇</a>实现了一个互斥器，看一下C++11提供的互斥器的用法。      </p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span>

<span class="built_in">std</span>::mutex one_mutex;

{
    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(one_mutex);
    ... ...
}
</code></pre><h3 id="3-_死锁：解决方案">3. 死锁：解决方案</h3><h4 id="避免嵌套锁">避免嵌套锁</h4><p>第一个建议往往是最简单的：一个线程已获得一个锁时，再别去获取第二个(don’t acquire a lock if you already hold one)。当你需要获取多个锁，使用一个<strong>std::lock</strong>来做这件事(对获取锁的操作上锁)，避免产生死锁。</p>
<h4 id="避免在持有锁时调用用户提供的代码">避免在持有锁时调用用户提供的代码</h4><p>第二个建议是次简单的：因为代码是用户提供的，你没有办法确定用户要做什么；用户程序可能做任何事情，包括获取锁。</p>
<h4 id="使用固定顺序获取锁">使用固定顺序获取锁</h4><p>当硬性条件要求你获取两个以上(包括两个)的锁，并且不能使用<strong>std::lock</strong>单独操作来获取它们;那么最好在每个线程上，用固定的顺序获取它们获取它们(锁)。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/concurrency-program/" itemprop="url">
                  C++ 并发编程 —— 《Linux多线程服务端编程》笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-18T15:05:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/18/concurrency-program/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/18/concurrency-program/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>好长一段时间没有写文章了，这次总结一下陈硕大大写的《Linux多线程服务端编程》一书第二章的读书笔记。</p>
</blockquote>
<h3 id="1-互斥器（mutex）">1.互斥器（mutex）</h3><p>使用互斥器的基本原则：</p>
<ul>
<li>用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作。Java里面的synchronized语句和C#的using语句也有类似的效果，即保证所得生效期间等于一个作用于，不会因异常而忘记解锁。</li>
<li>只用非递归的mutex（即不可重入的mutext）</li>
<li>不手工调用lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责。</li>
<li>在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因为锁顺序不同而导致死锁。</li>
<li>进程间通信使用socket，不要使用mutex。</li>
<li>加锁、解锁在同一个线程（RAII会保证）。</li>
<li>别忘记解锁（RAII会保证）。</li>
<li>不要重复解锁（RAII会保证）。</li>
<li>必要的时候可以考虑用PTHREAD_MUTEX_ERRORCHECK来排错。</li>
</ul>
<p>基本的互斥器的代码如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="type">MutexLock</span> {
public:
    <span class="type">MutexLock</span><span class="container">()</span> {
        pthread_mutex_init<span class="container">(&amp;<span class="title">_mutex</span>, <span class="type">NULL</span>)</span>;
    }

    ~<span class="type">MutexLock</span><span class="container">()</span> {
        pthread_mutex_destroy<span class="container">(&amp;<span class="title">_mutex</span>)</span>;
    }

    <span class="type">MutexLock</span>&amp; operator=<span class="container">(<span class="type">MutexLock</span>&amp; <span class="title">other</span>)</span> = delete;
    <span class="type">MutexLock</span><span class="container">(<span class="type">MutexLock</span>&amp; <span class="title">other</span>)</span> = delete;

    void lock<span class="container">()</span> {
        pthread_mutex_lock<span class="container">(&amp;<span class="title">_mutex</span>)</span>;
    }

    void unlock<span class="container">()</span> {
        pthread_mutex_unlock<span class="container">(&amp;<span class="title">_mutex</span>)</span>;
    }

    pthread_mutex_t* getRawMutex<span class="container">()</span> {
        return &amp;_mutex;
    }

private:
    pthread_mutex_t _mutex;
};

<span class="keyword">class</span> <span class="type">MutexGuard</span> {
public:
    <span class="type">MutexGuard</span><span class="container">(<span class="type">MutexLock</span>&amp; <span class="title">mutex</span>)</span>
    :_lock<span class="container">(<span class="title">mutex</span>)</span> {
        _lock.lock<span class="container">()</span>;
    }

    ~<span class="type">MutexGuard</span><span class="container">()</span> {
        _lock.unlock<span class="container">()</span>;
    }
private:
    <span class="type">MutexLock</span>&amp; _lock;
};</span>
</code></pre><h3 id="2-条件变量（condition_variable）">2.条件变量（condition variable）</h3><p>如果需要等待某个条件成立，我们应该使用条件变量。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量的学名叫管程（monitor）。Java Object内置的wait()、notify()、notifyAll()是条件变量。<br>对于wait端应该注意：    </p>
<ul>
<li>必须与mutex一起使用，该布尔表达式的读写接收此mutex的保护</li>
<li>在mutex已经上锁的时候才能调用wait()</li>
<li>把判断布尔条件和wait()放到while循环中     </li>
</ul>
<p>如下是一个简单的Condition实现</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="type">Condition</span> {
public:
    <span class="type">Condition</span><span class="container">(<span class="type">MutexLock</span>&amp; <span class="title">mutex</span>)</span>
    :_mutex<span class="container">(<span class="title">mutex</span>)</span> {
        pthread_cond_init<span class="container">(&amp;<span class="title">_cond</span>, <span class="type">NULL</span>)</span>;
    }

    ~<span class="type">Condition</span><span class="container">()</span> {
        pthread_cond_destroy<span class="container">(&amp;<span class="title">_cond</span>)</span>;
    }

    void wait<span class="container">()</span> {
        pthread_cond_wait<span class="container">(&amp;<span class="title">_cond</span>, <span class="title">_mutex</span>.<span class="title">getRawMutex</span>()</span>);
    }

    void notify<span class="container">()</span> {
        pthread_cond_signal<span class="container">(&amp;<span class="title">_cond</span>)</span>;
    }

    void notifyAll<span class="container">()</span> {
        pthread_cond_broadcast<span class="container">(&amp;<span class="title">_cond</span>)</span>;
    }
private:
    <span class="type">MutexLock</span>&amp; _mutex;
    pthread_cond_t _cond;
};</span>
</code></pre><h4 id="关于Spurious_wakeup（虚假唤醒）">关于Spurious wakeup（虚假唤醒）</h4><p>虚假唤醒在linux的多处理器系统中，在程序接收到信号前可能会发生。在Windows系统和JAVA虚拟机上也存在。在系统设计时应该可以避免虚假唤醒，但是这会影响条件变量的执行效率，而既然通过while循环就能避免虚假唤醒造成的错误，因此程序的逻辑就变成了while循环的情况。</p>
<h3 id="3-copy-on-write">3.copy-on-write</h3><p>主要思想是这样的：让读的加锁粒度尽量的小，但当写数据的时候，新的读请求是阻塞的。</p>
<pre><code><span class="literal">typedef</span> std::shared_ptr&lt;<span class="built_in">Map</span>&gt; MapPtr;    
MapPtr gData(<span class="keyword">new</span> <span class="built_in">Map</span>);     <span class="comment">// 有一个数据是需要共享的</span>

MapPtr getData() {   <span class="comment">// 读数据只有这一段是加锁的</span>
    MutexGuard guard(mutex);
    <span class="keyword">return</span> gData;
}

<span class="comment">// read threads</span>
MapPtr _data = getData(); 
<span class="comment">// process _data....</span>

<span class="comment">// write thread</span>
MutexGuard guard(mutex);    <span class="comment">// 写数据全场加锁</span>
<span class="keyword">if</span>(!gData.unique()) {
    MapPtr tmpData(<span class="keyword">new</span> <span class="built_in">Map</span>(gData.<span class="literal">get</span>()));
    gData.swap(tmpData);
}
<span class="comment">// process _data ...</span>
</code></pre><h3 id="4-小结">4.小结</h3><p>记得两年前开始了解C++多线程编程的时候看了陈硕的这本书，工作两年，由于长时间使用Python，对C++已经有些陌生了，更别说C++多线程编程了，今天再次拾起这本书，重读前面两章就当复习了。<br>接下来我会抽周末看一下《C++ Concurrency In Action》，也会陆续写一些相关的读书笔记。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/29/python-double-link-queue/" itemprop="url">
                  Python实现一个C版本的双向循环队列listex
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-29T14:06:51+08:00" content="2016-02-29">
              2016-02-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/29/python-double-link-queue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/29/python-double-link-queue/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>周末在家花了半天时间写了一个简单的双向循环链表，为什么要这样做，一是想比较一下Python原生的list和双向链表的性能差距是怎样的；二是看libuv的QUEUE源码，感觉libuv实现双向循环链表的方式还是很优雅的，打算借用一下。</p>
</blockquote>
<p>代码地址：<a href="https://github.com/Whosemario/ThinkIdeaEx/tree/master/python_list_ex" target="_blank" rel="external">https://github.com/Whosemario/ThinkIdeaEx/tree/master/python_list_ex</a></p>
<h3 id="安装">安装</h3><pre><code>&gt; python setup<span class="class">.py</span> build_ext --inplace
</code></pre><p>本地会生成一个listex.so的动态链接库。</p>
<h3 id="性能对比">性能对比</h3><h4 id="1-append方法">1.append方法</h4><p>双向循环链表测试代码：</p>
<pre><code>import <span class="tag">time</span>
import listex

<span class="tag">li</span> = listex.<span class="function"><span class="title">listex</span><span class="params">()</span></span>

start_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">10000000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>
end_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>

print <span class="string">"total time:"</span>, end_ts - start_ts
</code></pre><p>输出结果如下：</p>
<pre><code>total <span class="tag">time</span>: <span class="number">2.71579694748</span>
</code></pre><p>原生Python List测试代码：</p>
<pre><code>import <span class="tag">time</span>
import listex

<span class="tag">li</span> = listex.<span class="function"><span class="title">listex</span><span class="params">()</span></span>

start_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">10000000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>
end_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>

print <span class="string">"total time:"</span>, end_ts - start_ts
</code></pre><p>输出结果如下：</p>
<pre><code>total <span class="tag">time</span>: <span class="number">1.8892519474</span>
</code></pre><p>上面的结果可以看出来Python List的append的效率更高，这个是在意料之中的，Python List向后插入本来性能就不差，原因是Python List在容量不足时候会扩容，容量足够的时候append的内部实现就是<strong>数组赋值</strong>，性能肯定不差；而我的listex，在每次插入一个PyObject的时候，都要malloc一个队列节点（ListexNode）, 这个性能就会差很多了。</p>
<h4 id="2-pop方法">2.pop方法</h4><p>原生Python List从下标为0的地方pop出值：</p>
<pre><code>import <span class="tag">time</span>
import listex

<span class="tag">li</span> = []
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">100000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>

start_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">100000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">pop</span><span class="params">(<span class="number">0</span>)</span></span>
end_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>

print <span class="string">"total time:"</span>, end_ts - start_ts
</code></pre><p>输出结果如下：</p>
<pre><code>total <span class="tag">time</span>: <span class="number">2.07851791382</span>
</code></pre><p>使用listex，获取第一个listex node，并从队列中剔除：</p>
<pre><code>import <span class="tag">time</span>
import listex

<span class="tag">li</span> = listex.<span class="function"><span class="title">listex</span><span class="params">()</span></span>
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">100000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>

start_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>
<span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">xrange</span><span class="params">(<span class="number">0</span>, <span class="number">100000</span>)</span></span>:
    <span class="tag">li</span>.<span class="function"><span class="title">get_head</span><span class="params">()</span></span>.<span class="function"><span class="title">remove</span><span class="params">()</span></span>
end_ts = <span class="tag">time</span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>

print <span class="string">"total time:"</span>, end_ts - start_ts
</code></pre><p>输出几个如下：</p>
<pre><code>total <span class="tag">time</span>: <span class="number">0.0255160331726</span>
</code></pre><p>这种情况双向链表的优势就很明显了，Python List每次都要从头部pop出一个值，因此每次都要进行数据的整体移动，性能就很耗了。</p>
<h3 id="关于此工程">关于此工程</h3><p>现在这个双向链表的代码还是不完整，后面将会持续更新。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="whosemario" itemprop="image"/>
          <p class="site-author-name" itemprop="name">whosemario</p>
        </div>
        <p class="site-description motion-element" itemprop="description">里面有我的个人感悟和牢骚</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Whosemario" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whosemario</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"whosemaro"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
