<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="里面有我的个人感悟和牢骚">
<meta property="og:type" content="website">
<meta property="og:title" content="Whosemario的家">
<meta property="og:url" content="http://whosemario.github.io/index.html">
<meta property="og:site_name" content="Whosemario的家">
<meta property="og:description" content="里面有我的个人感悟和牢骚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Whosemario的家">
<meta name="twitter:description" content="里面有我的个人感悟和牢骚">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'always',
    motion: true
  };
</script>

  <title> Whosemario的家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Whosemario的家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="http://www.ixirong.com/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/14/about-socket-api-1/" itemprop="url">
                  Socket API 总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-10-14T15:31:03+08:00" content="2016-10-14">
              2016-10-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/14/about-socket-api-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/14/about-socket-api-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>总是反反复复在用socket api，但每次都要查询manual，接下来就总结一下这些api吧</p>
</blockquote>
<h2 id="基本的Socket_API">基本的Socket API</h2><h3 id="socket">socket</h3><pre><code>#incldue &lt;sys/socket.<span class="keyword">h</span>&gt;
<span class="keyword">int</span> socket(<span class="keyword">int</span> domain, <span class="keyword">int</span> <span class="built_in">type</span>, <span class="keyword">int</span> protocal);
                Return <span class="keyword">file</span> descriptor <span class="keyword">on</span> success, <span class="built_in">or</span> -<span class="number">1</span> <span class="keyword">on</span> error
</code></pre><p><strong>domain:</strong> </p>
<ol>
<li>AF_INET用于IPv4, sockaddr_in, 32bit IPv4 address + 16bit port number</li>
<li>AF_INET6用于IPv6，sockaddr_in6， 128bit IPv6 address + 16bit port number</li>
</ol>
<p><strong>type:</strong></p>
<ol>
<li>SOCK_STREAM: TCP相关</li>
<li>SOCK_DGRAM: UDP相关</li>
</ol>
<p><strong>protocal:</strong><br>基本为0</p>
<h3 id="bind">bind</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr* addr, socklen_t addrlen)</span></span>;
                        Return <span class="number">0</span> on sucess, or -<span class="number">1</span> on error
</code></pre><p>关于struct sockaddr，其是一个通用的地址结构，sa_family用于指明是哪种类型（IPv4 or IPv6），sa_data就根据不同的结构进行调整</p>
<pre><code><span class="keyword">struct</span> sockaddr {
    <span class="keyword">sa_family_t</span> sa_family;   <span class="comment">/* Address family (AF_* constant) */</span>
    <span class="keyword">char</span> sa_data[<span class="number">14</span>];        <span class="comment">/* Socket address (size varies according to socket domain) */</span>
};

<span class="comment">/* IPv4 address */</span>
<span class="keyword">struct</span> in_addr {                <span class="comment">/* IPv4 4-byte address */</span>
    <span class="keyword">in_addr_t</span> s_addr;           <span class="comment">/* Unsigned 32-bit integer */</span>
};

<span class="keyword">struct</span> sockaddr_in {            <span class="comment">/* IPv4 socket address */</span>
    <span class="keyword">sa_family_t</span>    sin_family;  <span class="comment">/* Address family (AF_INET) */</span>
    <span class="keyword">in_port_t</span>      sin_port;    <span class="comment">/* Port number */</span>
    <span class="keyword">struct</span> in_addr sin_addr;    <span class="comment">/* IPv4 address */</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span>  __pad[X];    <span class="comment">/* Pad to size of 'sockaddr' structure (16 bytes) */</span>
};
</code></pre><h3 id="listen">listen</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;
                     Return <span class="number">0</span> on success, or -<span class="number">1</span> on error
</code></pre><p>关于backlog:简单说就是定义pending队列的长度</p>
<h3 id="accept">accept</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, socklen_t *addrlen)</span></span>;
                     Return file descriptor on success, or -<span class="number">1</span> on error
</code></pre><p>accept的三个参数就比较好理解了，accept后面两个参数是链接过来的ip和port</p>
<h3 id="connect">connect</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, socklen_t addrlen)</span></span>;
                     Return <span class="number">0</span> on success, or -<span class="number">1</span> on error
</code></pre><h2 id="网络格式">网络格式</h2><p>网络传输都是大端传输的，所有我们需要对ip和port进行转换（转为大端）。<br>大端：高位在低地址<br>小端：高位在高地址   </p>
<pre><code><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>

uint16_t htons(uint16_t host_uint16);  /* host <span class="keyword">to</span> net */
                     <span class="keyword">Return</span> host_uint16 converted <span class="keyword">to</span> network <span class="built_in">byte</span> <span class="keyword">order</span>
uint32_t htonl(uint32_t host_uint32);  /* host <span class="keyword">to</span> net */
                     <span class="keyword">Return</span> host_uint32 converted <span class="keyword">to</span> network <span class="built_in">byte</span> <span class="keyword">order</span>
uint16_t ntohs(uint16_t net_uint16);   /* net <span class="keyword">to</span> host */
                     <span class="keyword">Return</span> net_uint16 coverted <span class="keyword">to</span> host <span class="built_in">byte</span> <span class="keyword">order</span>
uint32_t ntohl(uint32_t net_uint32);   /* net <span class="keyword">to</span> host */
                     <span class="keyword">Return</span> net_uint32 converted <span class="keyword">to</span> host <span class="built_in">byte</span> <span class="keyword">order</span>
</code></pre><h3 id="inet_pton和inet_ntop函数">inet_pton和inet_ntop函数</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> * src_str, <span class="keyword">void</span> *addrptr)</span></span>;
                     Return <span class="number">1</span> on successful conversion, <span class="number">0</span> <span class="keyword">if</span> src_str is not in 
                     presentation format, or -<span class="number">1</span> <span class="function">on error

<span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span>* addrptr, <span class="keyword">char</span> *dst_str, size_t len)</span></span>;
                     Returns pointer to dst_str on success, or <span class="literal">NULL</span> on error
</code></pre><p>inet_pton是将字符串转为<strong>in_addr</strong>或者<strong>in6_addr</strong>，因此两个函数的addrptr传入的就是上面这两个addr类型；另外第二个api的<strong>len</strong>参数是表示dst_str长度的</p>
<h2 id="持续更新中…">持续更新中…</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/08/talk-about-internal-dict/" itemprop="url">
                  浅谈__dict__
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-10-08T18:38:23+08:00" content="2016-10-08">
              2016-10-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/python的那些事/" itemprop="url" rel="index">
                    <span itemprop="name">python的那些事</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/08/talk-about-internal-dict/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/08/talk-about-internal-dict/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>今天看了一下Python源码，简单了解获取__dict__的流程，这里做一下简单的总结，为后续回头查看提供方便</p>
</blockquote>
<h3 id="Class的__dict__">Class的__dict__</h3><p>先看一个例子：</p>
<pre><code>&gt; class <span class="function"><span class="title">A</span><span class="params">(object)</span></span>: pass
&gt; ...
&gt; A.__dict__
<span class="function"><span class="title">dict_proxy</span><span class="params">({<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'__doc__'</span>: None})</span></span>
</code></pre><p>发现dict是一个<strong>dict_proxy</strong>类型，为何不是一个简单的python dict呢？跟一下代码看一下：</p>
<pre><code>case LOAD_ATTR:
    w = GETITEM(names, oparg)<span class="comment">;</span>
    v = TOP()<span class="comment">;</span>
    x = PyObject_GetAttr(v, w)<span class="comment">;</span>
    Py_DECREF(v)<span class="comment">;</span>
    SET_TOP(x)<span class="comment">;</span>
    if (x != NULL) continue<span class="comment">;</span>
    break<span class="comment">;</span>
</code></pre><p>获取变量会执行<strong>LOAD_ATTR</strong>的机器码，对于Class A会走到如下函数：</p>
<pre><code># in typeobject.c
static PyObject *
type_getattro(PyTypeObject *type, PyObject *name) {
    ...
    met<span class="built_in">a_attribute</span> = _PyType_Lookup(metatype, name)<span class="comment">;  【1】</span>
    <span class="keyword">if</span> (met<span class="built_in">a_attribute</span> != NULL) {
    met<span class="built_in">a_get</span> = Py_TYPE(met<span class="built_in">a_attribute</span>)-&gt;tp_descr_get<span class="comment">;</span>

    <span class="keyword">if</span> (met<span class="built_in">a_get</span> != NULL &amp;&amp; PyDescr_IsData(met<span class="built_in">a_attribute</span>)) {
        /* Data descriptors implement tp_descr_set to intercept
         * writes. Assume the attribute is <span class="literal">not</span> overridden in
<span class="label">         * type's tp_dict (and bases):</span> call the descriptor now.
         */
        <span class="keyword">return</span> met<span class="built_in">a_get</span>(met<span class="built_in">a_attribute</span>, (PyObject *)type,
                        (PyObject *)metatype)<span class="comment">;   【2】</span>
    }

}
</code></pre><p><strong>metatype</strong>：对于一个Class的Metatype是<strong>type</strong>，对于Class，会在type中寻找__dict__（参考1），返回一个描述符，并调用描述符get函数（参考2）。</p>
<p>最终会运行到下面的代码：</p>
<pre><code># <span class="keyword">in</span> typeobject.c
<span class="title">static</span> <span class="type">PyObject</span> *
<span class="title">type_dict</span>(<span class="type">PyTypeObject</span> *<span class="typedef"><span class="keyword">type</span>, void *context)</span>
{
    <span class="keyword">if</span> (<span class="typedef"><span class="keyword">type</span>-&gt;tp_dict == <span class="type">NULL</span>) <span class="container">{
        <span class="type">Py_INCREF(Py_None)</span>;
        return <span class="type">Py_None</span>;
    }</span></span>
    return <span class="type">PyDictProxy_New</span>(<span class="typedef"><span class="keyword">type</span>-&gt;tp_dict); 【1】</span>
}
</code></pre><p>【1】这里type就是Class A，所有就是读取Class A的tp_dict</p>
<h3 id="Instance的__dict__">Instance的__dict__</h3><p>读取一个类的实例的__dict__会调用到如下方法：</p>
<pre><code><span class="comment"># in object.c</span>
PyObject <span class="keyword">*</span>
_PyObject_GenericGetAttrWithDict(PyObject <span class="keyword">*</span>obj, PyObject <span class="keyword">*</span>name, PyObject <span class="keyword">*</span>dict) {
    ....
    descr = _PyType_Lookup(tp, name);   【1】

}
</code></pre><p>这里<strong>tp</strong>就是Class A，因此我们需要在Class A的tp<em>dict寻找\</em>_dict__变量，ok，使用下面的方式看一下：</p>
<pre><code>&gt; A.__dict__[<span class="string">"__dict__"</span>]
&lt;attribute '__dict__' <span class="keyword">of</span> <span class="attribute">'A</span>' objects&gt;
&gt; <span class="class"><span class="keyword">type</span></span>(A.__dict__[<span class="string">"__dict__"</span>])
&lt;<span class="class"><span class="keyword">type</span> '<span class="title">getset_descriptor</span>'&gt;</span>
</code></pre><p>这样会调用到对应的descriptor</p>
<pre><code><span class="preprocessor"># in typeobject.c</span>
<span class="function"><span class="keyword">static</span> PyObject *
<span class="title">subtype_dict</span><span class="params">(PyObject *obj, <span class="keyword">void</span> *context)</span> </span>{
    ....
    dictptr = _PyObject_GetDictPtr(obj);
    ....
    dict = *dictptr;
    ....
    <span class="keyword">return</span> dict;
}
</code></pre><p>上面的obj就是Class A的实例。</p>
<h3 id="Module的__dict__">Module的__dict__</h3><p>Module的基本逻辑与Instance相似，也是调用<strong>_PyObject_GenericGetAttrWithDict</strong>方法。</p>
<pre><code>&gt; <span class="class"><span class="keyword">type</span></span>(a_p).__dict__['__dict__']
&lt;<span class="keyword">member</span> '__dict__' <span class="keyword">of</span> '<span class="keyword">module</span>' objects&gt;
&gt; <span class="class"><span class="keyword">type</span></span>(<span class="class"><span class="keyword">type</span></span>(a_p).__dict__['__dict__'])
&lt;<span class="class"><span class="keyword">type</span> '<span class="title">member_descriptor</span>'&gt;</span>
</code></pre><p>会拿到module的__dict__，然后调用描述符对应的get函数。</p>
<pre><code><span class="comment"># in structmember.c</span>
PyObject <span class="keyword">*</span>
PyMember_GetOne(const char <span class="keyword">*</span>addr, PyMemberDef <span class="keyword">*</span>l) 
....
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/04/google-perftool-2/" itemprop="url">
                  【翻译】heap-checking using tcmalloc
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-10-04T19:20:08+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/04/google-perftool-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/04/google-perftool-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>前一阵子在项目中使用tcmalloc的heap-checker查找内存泄露的问题，今天翻译一下官方文档的一篇heap-checker相关的文章，由于时间有限，没有完全翻译完，只翻译了比较重要的部分，后续将会补全。</p>
</blockquote>
<p>在Google，我们使用heap checker检查C++程序的内存泄露。使用heap checker分三步：将lib库链接到应用中；运行代码；分析输出结果。</p>
<h3 id="链接tcmalloc">链接tcmalloc</h3><p>heap-checker是tcmalloc的一部分，为了在应用程序中安装heap checker，在程序链接阶段需要加入-ltcmalloc。但上面这种方法并不是唯一的方式，我们可以使用LD_PRELOAD宏在程序运行时加入tcmalloc：</p>
<pre><code><span class="comment">% env LD_PRELOAD="/usr/lib/libtcmalloc.so"</span>
</code></pre><p>上面这种方式并没有打开heap checking；仅仅将代码插入到程序中。因此，在开发阶段我们建议使用链接tcmalloc库的方法，这也是我们在Google使用的方法（然而，我们也可以使用环境变量开启profiler，因此通过链接tcmalloc库并不是必须的。）。需要注意的是为了使用heap checker必须使用tcmalloc内存分配库。</p>
<h3 id="运行代码">运行代码</h3><p>注意：由于一些安全原因，对于setuid程序，heap profiler在使用的过程中并不会写文件。</p>
<h2 id="对整个程序进行内存泄露检查">对整个程序进行内存泄露检查</h2><p>我们推荐使用heap-checker的方式是“全程序”模式。在这种模式下，heap-checker在main()函数开始之前跟踪内存分配，在程序介绍的时候再次检查。如果发现有内存泄露（任何已经分配的内存在程序结束的时候并没有对象引用它们），程序将会中断（通过exit(1)）并且打印怎样跟踪内存泄露的信息（使用pprof）</p>
<p>heap-checker会记录每一次内存分配的调用栈，因此开启heap-checker会导致程序的内存增长并影响程序的性能。</p>
<p>下面介绍怎么开启全程序模式的内存泄露检查：</p>
<ol>
<li><p>定义环境变量 HEAPCHECK 声明内存泄露检查的模式。例如下面的方式：   </p>
<p> % env HEAPCHECK=normal /usr/local/bin/my_binary_compiled_with_tcmalloc</p>
</li>
</ol>
<p>没有其他的操作了。</p>
<p>需要注意的是heap-checker使用heap-profiling的架构，因此不可能同时运行heap-checker和heap-profiler。</p>
<h3 id="内存检查的特性">内存检查的特性</h3><p>如下是在使用全程序内存检查的合法变量：</p>
<ol>
<li>minimal</li>
<li>normal</li>
<li>strict</li>
<li>draconian</li>
</ol>
<p>“minimal”的模式开始内存泄露检查尽可能晚，意味着你可以在初始化例程存在一些内存泄露（在main()函数前），但并不会让heap-checker记录。如果你在全局初始化时候存在内存泄露，“minimal”模式就很适合。否则，你应该使用更加严格的模式。</p>
<p>“normal”模式跟踪存活对象（live objects）并报告其内存泄露信息（在程序结束时，无法通过存活对象找到的内存空间都是内存泄露）</p>
<p>“strict”模式与“normal”模式很相似，但“strict”模式会监控全局变量析构函数的内存泄露。例如，如果你有一个全局变量，在运行时申请了部分内存，在析构函数中忘记释放内存，在“strict”模式下将会被监控到，在“normal”模式下将不会。</p>
<p>“draconian”模式适合想清晰了解应用程序内存管理的情况，其希望heap-checker去帮助他们优化内存管理。在“draconian”模式，heap-checker并不会只检查存活对象，只要有内存泄露，其都会报告。</p>
<p>“normal”模式是最常用的模式。</p>
<p>as-is”是一个更加灵活的模式；它允许你自定义heap-checker的一些特性。“local”激活“显式heap-check指令”，但并不会开启任何全程序内存泄露检查。</p>
<h2 id="用于调试内存泄露的小方法">用于调试内存泄露的小方法</h2><h3 id="工作原理">工作原理</h3><p>当一个HeapLeakChecker对象被构造的时候，它会在tmp文件夹输出一个名为<prefix>.<name>-beg.heap的记录内存使用信息的文件。当NoLeak()被调用的时候（对于全程序检查，其发生在程序结束），它将输出一个名为<prefix>.<name>-end.heap的文件（<prefix>是自动诊断的，<name>是argv[0]的内容）。heap-checker将会对比这两个文件。如果第二个文件使用了过多的内存使用量，NoLeaks()函数将会返回false。对于全程序，这种情况将会引起程序中断。所有情况下都将会打印如何处理dump文件的信息。</name></prefix></name></prefix></name></prefix></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/27/google-preftool-1/" itemprop="url">
                  Google Perftools Mac OS 安装与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-09-27T12:52:15+08:00" content="2016-09-27">
              2016-09-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/27/google-preftool-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/27/google-preftool-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>项目用到了tcmalloc，然后发现项目有内存泄露，因此略微玩了一下Google Perftools</p>
</blockquote>
<h3 id="1-安装">1.安装</h3><p>目前Google Perftools的Repo在<a href="https://github.com/gperftools/gperftools/tree/master" target="_blank" rel="external">https://github.com/gperftools/gperftools/tree/master</a></p>
<p>我们可以下载8.0的Release版本 <a href="https://github.com/gperftools/gperftools/tree/at8_0-release" target="_blank" rel="external">https://github.com/gperftools/gperftools/tree/at8_0-release</a></p>
<p>下载之后进行解压:</p>
<pre><code><span class="blockquote">&gt; cd google-perftool</span>
<span class="blockquote">&gt; ./autogen.sh</span>
<span class="blockquote">&gt; ./configure --prefix=&lt;build_path&gt;</span>
<span class="blockquote">&gt; make</span>
<span class="blockquote">&gt; make install</span>
</code></pre><p>安装成功！</p>
<h3 id="2-使用">2.使用</h3><p>使用方法很简单，目前我们项目使用方式如下(Linux下)：</p>
<pre><code><span class="keyword">export</span> LD_PRELOAD=&lt;build_path&gt;<span class="regexp">/lib/</span>libtcmalloc.so
</code></pre><h3 id="3-Heap_Profile">3.Heap Profile</h3><p>我们可以将tcmalloc使用Heap的信息dump出来，通过pprof工具进行查看。</p>
<pre><code>env HEAPPROFILE=<span class="string">"./perf_log/game.log"</span> HEAP_PROFILE_ALLOCATION_INTERVAL=<span class="number">10000000</span> &lt;program&gt;
</code></pre><p><strong>HEAPPROFILE</strong>: 用于指明dump出来的log信息的前缀<br><strong>HEAP_PROFILE_ALLOCATION_INTERVAL</strong>: 定义采样频率，默认是1G，当tcmalloc分配内存到达配置值时，将会dump出log</p>
<h5 id="查看信息">查看信息</h5><p>比如我们的<program>是python</program></p>
<pre><code>pporf --<span class="keyword">text</span> /usr/bin/<span class="keyword">python</span> game.<span class="keyword">log</span><span class="number">.0001</span>.heap
</code></pre><h3 id="4-Heap_Leak_Profile">4.Heap Leak Profile</h3><p>我们可以使用tcmalloc的Heap Checker去检查内存泄露</p>
<pre><code>env HEAPCHECK=normal &lt;<span class="function"><span class="keyword">program</span></span>&gt;
</code></pre><p>Heap Checker会在程序结束的时候打印出leak数据，并会提示使用什么指令进行详细信息的查看。</p>
<p>–text: 文本数据<br>–pdf: 调用栈的信息</p>
<h3 id="5-References">5.References</h3><ol>
<li><a href="http://dirtysalt.info/gperftools.html#orgheadline2" target="_blank" rel="external">http://dirtysalt.info/gperftools.html#orgheadline2</a> – 对log信息的说明</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/cpp-right-ref/" itemprop="url">
                  C++11的右值引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-09-05T09:32:46+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/05/cpp-right-ref/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/05/cpp-right-ref/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>好久没有写文章了，一是因为最近公司项目比较紧，二是在看c++，工作两年多c++的知识都忘记了，今天就来简单总结一下c++11的右值引用。<br>提前声明，本文参考了<a href="http://www.cnblogs.com/qicosmos/p/4283455.html" target="_blank" rel="external">从4行代码看右值引用</a></p>
</blockquote>
<h4 id="1-右值引用要解决的问题">1.右值引用要解决的问题</h4><p>c++11引入右值引用要解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。<br>在c++11中所有的值分为三种类型：左值、将亡值、纯右值。纯右值是非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等；将亡值是将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。</p>
<h4 id="2-几个尝试性的测试">2.几个尝试性的测试</h4><p>测试基本代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> g_contr_cnt = <span class="number">0</span>;
<span class="keyword">int</span> g_decontr_cnt = <span class="number">0</span>;
<span class="keyword">int</span> g_copy_cnt = <span class="number">0</span>;

<span class="keyword">class</span> A {
<span class="keyword">public</span>:
    A() {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct: "</span> &lt;&lt; ++g_contr_cnt &lt;&lt; endl;
    }

    A(<span class="keyword">const</span> A&amp; oth) {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy: "</span> &lt;&lt; ++g_copy_cnt &lt;&lt; endl;
    }

    ~A() {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct: "</span> &lt;&lt; ++g_decontr_cnt &lt;&lt; endl;
    }
};

<span class="function">A <span class="title">getVal</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> A();
}
</code></pre><h5 id="测试1：值拷贝">测试1：值拷贝</h5><pre><code><span class="keyword">A</span> x = getVal()<span class="comment">;</span>
</code></pre><p>由于编辑器会对代码进行优化，因此我们在编译上面的代码的时候，加入-fno-elide-constructors，运行结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">3</span>
</code></pre><p>调用了两次复制构造函数，一次在返回值，一次在对x的赋值。如果A类的复制构造函数不是简简单单地打印信息，而是有大量内存的拷贝，那怎么办？两次复制构造函数性能开销就会很大，并且关键的是拷贝源实例是一个将亡值，留下它根本没有什么用。</p>
<p><strong>换一种方案：const A&amp;</strong></p>
<pre><code>const <span class="keyword">A</span>&amp; x = getVal()<span class="comment">;</span>
</code></pre><p>这时候输出结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">copy</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
</code></pre><p>但const reference是不能修改引用的内容的！</p>
<p><strong>另一个方案：右值引用</strong></p>
<pre><code><span class="keyword">A</span>&amp;&amp; x = getVal()<span class="comment">;</span>
</code></pre><p>这样输出结果与上面一种方案是一样的，并且x并不是一个const类型。右值引用将返回的值“续命”了。</p>
<h5 id="测试2：移动构造函数">测试2：移动构造函数</h5><p>我们现在类的定义中加入移动构造函数：</p>
<pre><code><span class="literal">A</span>(<span class="literal">A</span>&amp;&amp; oth) {
    cout &lt;&lt; <span class="string">"move: "</span> &lt;&lt; ++g_move_cnt &lt;&lt; endl<span class="comment">;</span>
}
</code></pre><p>这样子，我们再看一下输出结果：</p>
<pre><code><span class="keyword">A</span> x = getVal()<span class="comment">;</span>
</code></pre><p>输出结果如下：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
<span class="attribute">deconstruct</span>: <span class="string">3</span>
</code></pre><p>没有拷贝构造函数了，与之代替的是移动构造函数，移动构造函数的实现，我们可以认为移动源实例是一个将亡值，这样我们在移动构造函数的内部实现中只需要将移动源实例move到新的实例中即可。</p>
<h4 id="测试3：参数A&amp;&amp;">测试3：参数A&amp;&amp;</h4><pre><code><span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(A&amp;&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;
</code></pre><p>这两个函数，编译器是怎样判断的呢？做了一些尝试：</p>
<pre><code>A x<span class="comment">;</span>
setVal<span class="list">(<span class="keyword">x</span>)</span><span class="comment">;   // 左值</span>
setVal<span class="list">(<span class="keyword">std</span>:<span class="keyword">:move</span><span class="list">(<span class="keyword">x</span>)</span>)</span><span class="comment">;   // 右值</span>
setVal<span class="list">(<span class="keyword">A</span><span class="list">()</span>)</span><span class="comment">;   // 右值</span>
A&amp;&amp; y = getVal<span class="list">()</span><span class="comment">;</span>
setVal<span class="list">(<span class="keyword">y</span>)</span><span class="comment">;  // 左值</span>
</code></pre><h4 id="测试4：std::move">测试4：std::move</h4><p>std::move是c++11提供移动实例的方式，测试代码如下：</p>
<pre><code><span class="keyword">A</span> x<span class="comment">;</span>
<span class="keyword">A</span> y = st<span class="number">d::</span>move(x)<span class="comment">;</span>
</code></pre><p>y的初始化使用了移动构造函数：</p>
<pre><code><span class="attribute">construct</span>: <span class="string">1</span>
<span class="attribute">move</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">1</span>
<span class="attribute">deconstruct</span>: <span class="string">2</span>
</code></pre><p>如果类A没有移动构造函数，将会使用复制构造函数。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/20/lscpu-cmd/" itemprop="url">
                  lscpu中的 socket、core、thread的意义
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-05-20T14:17:33+08:00" content="2016-05-20">
              2016-05-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/20/lscpu-cmd/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/20/lscpu-cmd/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Linux上如下指令可以查看CPU的信息</p>
<pre><code><span class="blockquote">&gt; lscpu</span>
</code></pre><p>在我们线上机器上的结果如下：</p>
<pre><code>Architecture:          x86_64
CPU <span class="function"><span class="title">op-mode</span><span class="params">(s)</span></span>:        <span class="number">32</span>-bit, <span class="number">64</span>-bit
Byte Order:            Little Endian
<span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:                <span class="number">32</span>
On-line <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span> list:   <span class="number">0</span>-<span class="number">31</span>
<span class="function"><span class="title">Thread</span><span class="params">(s)</span></span> per core:    <span class="number">2</span>
<span class="function"><span class="title">Core</span><span class="params">(s)</span></span> per socket:    <span class="number">8</span>
<span class="function"><span class="title">Socket</span><span class="params">(s)</span></span>:             <span class="number">2</span>
NUMA <span class="function"><span class="title">node</span><span class="params">(s)</span></span>:          <span class="number">2</span>
Vendor ID:             GenuineIntel
CPU family:            <span class="number">6</span>
Model:                 <span class="number">62</span>
Model name:            <span class="function"><span class="title">Intel</span><span class="params">(R)</span></span> <span class="function"><span class="title">Xeon</span><span class="params">(R)</span></span> CPU E5-<span class="number">2640</span> v2 @ <span class="number">2.00</span>GHz
Stepping:              <span class="number">4</span>
CPU MHz:               <span class="number">1320.468</span>
CPU max MHz:           <span class="number">2500.0000</span>
CPU min MHz:           <span class="number">1200.0000</span>
BogoMIPS:              <span class="number">4000.99</span>
Virtualization:        VT-x
L1d cache:             <span class="number">32</span>K
L1i cache:             <span class="number">32</span>K
L2 cache:              <span class="number">256</span>K
L3 cache:              <span class="number">20480</span>K
NUMA node0 <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:     <span class="number">0</span>-<span class="number">7</span>,<span class="number">16</span>-<span class="number">23</span>
NUMA node1 <span class="function"><span class="title">CPU</span><span class="params">(s)</span></span>:     <span class="number">8</span>-<span class="number">15</span>,<span class="number">24</span>-<span class="number">31</span>
</code></pre><p>上面的信息，有几个比较有意思：</p>
<pre><code><span class="function"><span class="title">Thread</span><span class="params">(s)</span></span> per core:    <span class="number">2</span>
<span class="function"><span class="title">Core</span><span class="params">(s)</span></span> per socket:    <span class="number">8</span>
<span class="function"><span class="title">Socket</span><span class="params">(s)</span></span>:             <span class="number">2</span>
</code></pre><h5 id="什么是Socket">什么是Socket</h5><p>Socket就是主板上插CPU的槽的数量</p>
<h5 id="什么是Core">什么是Core</h5><p>Core就是平时说的核，双核、四核等，就是每个CPU上的核数</p>
<h5 id="什么是Thread">什么是Thread</h5><p>thread就是每个core上的硬件线程数，即超线程</p>
<p>对操作系统来说，其逻辑CPU的数量就是Socket*Core*Thread</p>
<h3 id="参考资料">参考资料</h3><p>[1] <a href="http://diego.assencio.com/?index=614d73283d49e939ebfb648cfb86819d" target="_blank" rel="external">Getting CPU architecture information with lscpu</a><br>[2] <a href="http://blog.chinaunix.net/uid-20940095-id-3596134.html" target="_blank" rel="external"> 处理器三个概念理解及延伸（socket，core，thread，SMT，CMP，SMP）</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/virtual-memory/" itemprop="url">
                  虚拟内存管理（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-05-18T16:18:51+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/virtual-memory/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/virtual-memory/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>很久以前就想写一下关于虚拟内存管理方面的文章，主要还是写给自己看的。原因主要是自己对Linux虚拟内存管理也是一知半解，写一篇博客，记录一下自己这几天的学习笔记，留着以后做参考。</p>
</blockquote>
<p>这一篇主要讲一下虚拟地址到物理地址的转换。主要参考《深入理解计算机系统》一书。</p>
<h3 id="关于逻辑地址、线性地址和物理地址">关于逻辑地址、线性地址和物理地址</h3><h5 id="物理地址：">物理地址：</h5><p>物理地址可以想象成实际物理存储上的地址 </p>
<h5 id="线性地址：">线性地址：</h5><p>线性地址也可以叫做虚拟地址，是一个不真实的地址，可以理解为页式管理中的地址      </p>
<h5 id="逻辑地址：">逻辑地址：</h5><p>逻辑地址与线性地址一样，是一个不真实的地址，用于Intel段式管理中的地址      </p>
<h5 id="三个地址的转换关系：">三个地址的转换关系：</h5><p>逻辑地址–&gt;线性地址–&gt;物理地址</p>
<h3 id="逻辑地址–&gt;线性地址">逻辑地址–&gt;线性地址</h3><p>逻辑地址由两部分组成，段标识符和段内偏移地址。段标识符是有个16位长的字段组成，叫做段选择符。其中高13位是一个索引号，如下图：<br><img src="/images/virtual-memory-1-1.png" alt=""></p>
<p>索引号用于索引段描述符表的某一段描述符，段描述符格式如下图：<br><img src="/images/virtual-memory-1-2.png" alt=""></p>
<p>在Linux下，段描述符的Base都是0，因此逻辑地址的段内偏移量就是线性地址，接下来看一下线性地址怎样转换成物理地址的。</p>
<h3 id="线性地址–&gt;物理地址">线性地址–&gt;物理地址</h3><p>首先宏观上的看一下线性地址（虚拟地址）到物理地址的转换<br><img src="/images/virtual-memory-1-3.png" alt=""></p>
<p>虚拟地址高位有一个页表索引，通过页表索引可以在页表中找到对应的一个页表入口(Page Table Entry)，在PTE中可以得到物理页号，然后在加上原先在虚拟地址中的偏移量，就会定位到最终的地址。</p>
<h4 id="基本流程">基本流程</h4><p><img src="/images/virtual-memory-1-4.png" alt=""></p>
<p>如上图是一个正常的命中流程：    </p>
<ol>
<li>处理器生成一个虚拟地址，并将其给MMU</li>
<li>MMU生成一个PTE地址，从高速缓存/主存中请求获取</li>
<li>高速缓存/主存将PTE数据传回MMU</li>
<li>MMU生成物理地址，传给高速缓存/主存</li>
<li>高速缓存/主存将数据传回处理器</li>
</ol>
<p><img src="/images/virtual-memory-1-5.png" alt=""></p>
<p>上图是发生缺页中断的情况，高速缓存/主存会将牺牲页换出，将新页换进。</p>
<h4 id="利用TLB加速地址翻译">利用TLB加速地址翻译</h4><p>TLB全称翻译后备缓冲器(Translation Lookaside Buffer)，位于MMU内存，其实就是缓存住了一些PTE，那么MMU就不需要从高速缓存/主存中获取PTE了。</p>
<h4 id="多级页表">多级页表</h4><p>如果是32位的虚拟地址空间，一个页的大小为4K，那一张页表就有1M个PTE，如果每个PTE的大小为4个字节，那么页表占用内存大小为4MB。如果是64位机器，它的寻址位数是48位，那页表就更大了。<br>解决方式是讲页表分为多级，如下图：<br><img src="/images/virtual-memory-1-6.png" alt="">  </p>
<p>地址翻译的过程基本就差不多了。 </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/21/Mangos-Zero-1/" itemprop="url">
                  Mangos Zero 编译安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-21T19:49:41+08:00" content="2016-04-21">
              2016-04-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/21/Mangos-Zero-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/21/Mangos-Zero-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>本篇文章是我几个月前在CSDN的blog上写的，现在移过来</p>
<p>折腾了两天，终于将Mangos Zero在自己的Windows电脑上搭建起来了，下面总结一下安装Mangos Zero过程。网上也有很多安装Mangos Zero的教程，都比较老了，有些基本不能用了。</p>
</blockquote>
<h3 id="1-_安装环境">1. 安装环境</h3><ol>
<li>Windows XP 64位</li>
</ol>
<h3 id="2-_前期准备">2. 前期准备</h3><ol>
<li><a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">MySQL</a>（本人使用的是5.5的版本）</li>
<li><a href="http://code.google.com/p/sqlyog/wiki/Downloads" target="_blank" rel="external">SQLyog</a>（这个根据个人喜好，就是MySQL的GUI）</li>
<li><a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git</a></li>
<li>World of Warcraft 1.12 (Google找一下，我这边有一个，但忘记网址了，过一阵子上传到网盘上)</li>
<li>VS 2010 或更高版本 （本人是VS2013）</li>
</ol>
<h3 id="3-_安装MySQL">3. 安装MySQL</h3><p>MySQL的安装我就不多说了，不会的网上一大堆教程的，这里要记住MySQL安装过程中设置的密码，后面会用到。</p>
<h3 id="4-_安装Git">4. 安装Git</h3><p>安装指引一步一步安装就好，没有什么可注意的地方。</p>
<h3 id="5-_创建一个根目录">5. 创建一个根目录</h3><p>创建一个名为Mangos的根目录，下面的所有操作我们都会在这个目录下进行</p>
<h3 id="6-_下载database">6. 下载database</h3><pre><code>&gt; cd Mangos
&gt; git <span class="keyword">clone</span> <span class="title">--recursive</span> http://github.com/mangoszero/database.git -b develop21
</code></pre><p>这里要多少几句，我使用的是<strong>develop21</strong>分支，一开始我使用的是<strong>release20</strong>这个分支，但发现database和server的版本不匹配，并且按网上的说法打Patch都解决不了，所有就用了最新的开发分支，经本人测试完全可用。因为是开发分支，可能开发者在上面修改导致一些其他问题，所以我自己也fork了一个这样的分支，大家也可用clone我自己的git</p>
<pre><code>git <span class="keyword">clone</span> <span class="title">--recursive</span> https://github.com/Whosemario/database.git -b develop21
</code></pre><h3 id="7-将数据加载到MySQL">7.将数据加载到MySQL</h3><pre><code><span class="blockquote">&gt; cd Mangos</span>
<span class="blockquote">&gt; cd database</span>
<span class="blockquote">&gt; InstallDatabases.bat</span>
</code></pre><p>起始就是运行database文件夹下的<strong>InstallDatabases.bat</strong>脚本。跟着提示一路配置下去。几点要注意：</p>
<ol>
<li>第一步输入N进行下一步</li>
<li>MySQL的密码就是上面安装MySQL设置的密码</li>
<li>没有其他什么要求，剩下的配置都使用默认就好，下面的教程将根据默认配置来<br>如果一切顺利，你会在MySQL里面看到三个新的数据库，如下<br><img src="http://img.blog.csdn.net/20151205222912569" alt="这里写图片描述"><br>它们分别是<strong>character0</strong> <strong>mangos0</strong> <strong>realmd</strong><br>此时还没完，这里的character0的版本会和mangos server的版本不一致，打开character0的db_version这张表。<br><img src="http://img.blog.csdn.net/20151205223222361" alt="这里写图片描述"><br>它的structure一列位1，但server需要的版本为2，所以我们要为character0打个Patch，在database/Character/Updates/rel21/目录下有一个sql文件Rel21_2_0_honor_flush.sql，将其运行即可。</li>
</ol>
<h3 id="8-_下载server">8. 下载server</h3><pre><code>&gt; cd Mangos
&gt; git <span class="keyword">clone</span> <span class="title">https</span>://github.com/mangoszero/server.git --recursive -b develop21
</code></pre><p>相同的，我也有一个对应的repo</p>
<pre><code>git <span class="keyword">clone</span> <span class="title">https</span>://github.com/Whosemario/server.git -b develop21
</code></pre><h3 id="9-_编译server">9. 编译server</h3><p>到Mangos/server/win目录下，里面有很多安装软件，分别安装cmake和openssl，然后运行MaNGOS_EasyBuild.exe，点击按钮<strong>Check</strong> <strong>Now</strong>，如果上面的安装一切正常，会如图<br><img src="http://img.blog.csdn.net/20151205224009966" alt="这里写图片描述"><br>点击Build Options，会有一些基本选项，按自己的需求去选择，没有什么大问题，然后点击Generate Project，最后会打开你的Visual Studio，然后rebuild整个项目，项目rebuild成功后，会在Mangos文件加下生成<strong>server_build</strong>的目录，然后进行下面两步操作：</p>
<ol>
<li>将server_build/bin/Debug/下的文件都拷贝到你的WoW客户端的根目录（也就是WoW.exe所在的目录）</li>
<li>再将server_build/bin/Debug/tools/下的文件都拷贝到你的WoW客户端的根目录</li>
<li>在WoW客户端目录下，运行<strong>ExtractResources.sh</strong>，跟着指引一步一步配置，当运行完后，会生成三个目录 <strong>dbc</strong> <strong>maps</strong> <strong>vmaps</strong>。</li>
<li>在Mangos目录下新建名为Data的文件夹，将上面的三个目录拷贝到Data文件夹下</li>
</ol>
<h3 id="10-_配置Mangos_Server">10. 配置Mangos Server</h3><ol>
<li><p>进入Mangos/server_build/bin/Debug/文件夹下，将mangosd.conf.dist文件重命名为mangosd.conf，并修改里面的内容</p>
<pre><code><span class="setting">DataDir = <span class="value"><span class="string">"."</span>    </span></span>
</code></pre><p> 修改为</p>
<pre><code><span class="setting">DataDir = <span class="value"><span class="string">"C:\Mangos\Data"</span></span></span>
</code></pre><p> 假设你的Mangos新建在C盘根目录下。</p>
<pre><code>LoginDatabaseInfo      "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;realmd"</span>
WorldDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;mangos"</span>
ScriptDev2DatabaseInfo = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;mangos"</span>
CharacterDatabaseInfo  = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;character0"</span>
</code></pre></li>
</ol>
<p>修改为：</p>
<pre><code>LoginDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;realmd"</span>
WorldDatabaseInfo      = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;mangos0"</span>
ScriptDev2DatabaseInfo = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;mangos0"</span>
CharacterDatabaseInfo  = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;characters"</span>
</code></pre><p>假设你的MySQL密码为123456.</p>
<ol>
<li><p>将realmd.conf.dist文件重命名为realmd.conf</p>
<pre><code>LoginDatabaseInfo     = "<span class="number">127.0.0.1</span><span class="comment">;3306;mangos;mangos;realmd"</span>
</code></pre><p>改为：</p>
<pre><code>LoginDatabaseInfo     = "<span class="number">127.0.0.1</span><span class="comment">;3306;root;123456;realmd"</span>
</code></pre></li>
<li>修改realmd数据库里面的realmlist表，将第一列带有MaNGOS的字符串替换为MyWoW</li>
</ol>
<h3 id="11-_修改客户端">11. 修改客户端</h3><ol>
<li>打开realmlist.wtf，将最后的域名改为127.0.0.1</li>
</ol>
<h3 id="12-_启动游戏">12. 启动游戏</h3><ol>
<li>打开Mango\server_build\bin\Debug\realmd.exe<br> <img src="http://img.blog.csdn.net/20151205225953575" alt="这里写图片描述"></li>
<li>打开Mango\server_build\bin\Debug\mangosd.exe<br> <img src="http://img.blog.csdn.net/20151205230127299" alt="这里写图片描述"></li>
<li>新建一个玩家<br><img src="http://img.blog.csdn.net/20151205230359778" alt="这里写图片描述"></li>
<li><p>打开客户端WoW.exe<br><img src="http://img.blog.csdn.net/20151205232214037" alt="这里写图片描述"></p>
<h3 id="reference">reference</h3></li>
<li><p><a href="https://www.getmangos.eu/wiki/Installation%20Guides/Windows/MaNGOS%20Rel21.md" target="_blank" rel="external">How to Setup a MaNGOS Rel21 Server from Scratch</a></p>
</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/05/interview-book/" itemprop="url">
                  一本很有意义的GitBook
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-05T21:44:57+08:00" content="2016-04-05">
              2016-04-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/05/interview-book/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/05/interview-book/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>最近在维护一本<a href="https://www.gitbook.com/book/whosemario/interview-book/details" target="_blank" rel="external">Gitbook</a>，和面试相关的，本人将持续维护中…</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/26/docker-tutorial/" itemprop="url">
                  Mac OSX Docker 教程 (一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-26T19:09:32+08:00" content="2016-03-26">
              2016-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/26/docker-tutorial/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/26/docker-tutorial/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>本文基于Docker官方网站的<a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac OSX教程</a>所写。</p>
</blockquote>
<h3 id="安装Docker_Toolbox">安装Docker Toolbox</h3><p>Docker Toolbox包含如下的Docker工具：</p>
<ul>
<li>Docker CLI 用于创建Docker镜像和Docker容器</li>
<li>Docker Machine 让你可以在Mac OSX以命令行的方式操作Docker引擎</li>
<li>Docker Compose用于运行docker-compose命令</li>
<li>Kitematic —— Docker的GUI组件</li>
<li>Docker快速启动shell</li>
<li>Oracle VM 虚拟机</li>
</ul>
<h4 id="步骤一：检查系统版本号">步骤一：检查系统版本号</h4><p>检查操作系统版本号，版本号必须 &gt;= 10.8</p>
<h4 id="步骤二：安装Docker_Tool">步骤二：安装Docker Tool</h4><p>下载<a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="external">Docker Toolbox</a>并开始进行安装，安装很傻瓜，一路next就可以。</p>
<h4 id="步骤三：检查是否安装成功">步骤三：检查是否安装成功</h4><ol>
<li><p>首先开启Docker Quickstart Terminal</p>
<p> <img src="/images/docker-tutorial-1-p1.png" alt=""></p>
</li>
<li><p>终端会有如下输出</p>
<pre><code><span class="type">Last</span> login: <span class="type">Sat</span> <span class="type">Jul</span> <span class="number">11</span> <span class="number">20</span>:<span class="number">09</span>:<span class="number">45</span> on ttys002
bash '/<span class="type">Applications</span>/<span class="type">Docker</span> <span class="type">Quickstart</span> <span class="type">Terminal</span>.app/<span class="type">Contents</span>/<span class="type">Resources</span>/<span class="type">Scripts</span>/    start.sh'
<span class="type">Get</span> http:<span class="comment">///var/run/docker.sock/v1.19/images/json?all=1&amp;filters=%7B%22dangling%22%3A%5B%22true%22%5D%7D: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?</span>
<span class="type">Get</span> http:<span class="comment">///var/run/docker.sock/v1.19/images/json?all=1: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?</span>
-bash: lolcat: command not found

mary at meepers in ~
$ bash '/<span class="type">Applications</span>/<span class="type">Docker</span> <span class="type">Quickstart</span> <span class="type">Terminal</span>.app/<span class="type">Contents</span>/<span class="type">Resources</span>/<span class="type">Scripts</span>/start.sh'
<span class="type">Creating</span> <span class="type">Machine</span> dev...
<span class="type">Creating</span> <span class="type">VirtualBox</span> <span class="type">VM</span>...
<span class="type">Creating</span> <span class="type">SSH</span> key...
<span class="type">Starting</span> <span class="type">VirtualBox</span> <span class="type">VM</span>...
<span class="type">Starting</span> <span class="type">VM</span>...
<span class="type">To</span> see how to connect <span class="type">Docker</span> to <span class="keyword">this</span> machine, run: docker-machine env dev
<span class="type">Starting</span> machine dev...
<span class="type">Setting</span> environment variables <span class="keyword">for</span> machine dev...

                    ##         .
              ## ## ##        ==
           ## ## ## ## ##    ===
       /<span class="string">""""""</span><span class="string">""""""</span><span class="string">"""""\___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
       \______ o           __/
         \    \         __/
          \____\_______/

The Docker Quick Start Terminal is configured to use Docker with the “default” VM.</span>
</code></pre></li>
<li><p>键入<strong>docker run hello-world</strong></p>
<pre><code>$ docker run hello-world
Unable <span class="built_in">to</span> find image <span class="string">'hello-world:latest'</span> locally
latest: Pulling <span class="built_in">from</span> library/hello-world
<span class="number">535020</span>c3e8ad: Pull complete
af340544ed62: Pull complete
Digest: sha256:a68868bfe696c00866942e8f5ca39e3e31b79c1e50feaee4ce5e28df2f051d5c
Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest

Hello <span class="built_in">from</span> Docker.
This message shows that your installation appears <span class="built_in">to</span> be working correctly.

To generate this message, Docker took <span class="operator">the</span> following steps:
<span class="number">1.</span> The Docker Engine CLI client contacted <span class="operator">the</span> Docker Engine daemon.
<span class="number">2.</span> The Docker Engine daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub.
<span class="number">3.</span> The Docker Engine daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span> executable that produces <span class="operator">the</span> output you are currently reading.
<span class="number">4.</span> The Docker Engine daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker Engine CLI client, which sent <span class="keyword">it</span> <span class="built_in">to</span> your terminal.

To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>:
$ docker run -<span class="keyword">it</span> ubuntu bash

Share images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account:
<span class="keyword">https</span>://hub.docker.com

For more examples <span class="operator">and</span> ideas, visit:
<span class="keyword">https</span>://docs.docker.com/userguide/
</code></pre></li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="whosemario" itemprop="image"/>
          <p class="site-author-name" itemprop="name">whosemario</p>
        </div>
        <p class="site-description motion-element" itemprop="description">里面有我的个人感悟和牢骚</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">42</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Whosemario" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whosemario</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"whosemaro"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
